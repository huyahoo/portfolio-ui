// src/core/storage.ts
var getItem = (key) => {
  const val = JSON.parse(window.localStorage.getItem(key));
  if (!val) {
    return {};
  }
  return val.value || {};
};
var setItem = (key, value) => {
  let val = {
    value
  };
  let valStr = JSON.stringify(val);
  window.localStorage.setItem(key, valStr);
};
var removeItem = (key) => {
  window.localStorage.removeItem(key);
};
var storage = {
  getItem,
  setItem,
  removeItem
};
var storage_default = storage;

// src/core/options.ts
var defaultOptions = {
  key: "VUEX-PERSISTEDSTATE",
  paths: [],
  fetchBeforeUse: true,
  fetchBeforeUseFn(key, storage2) {
    return storage2.getItem(key);
  },
  storage: storage_default
};

// src/core/persistedstate.ts
function matchPaths(paths, mutation) {
  if (paths.length === 0) {
    return true;
  }
  const moduleName = mutation.type.split("/")[0];
  if (!moduleName) {
    return false;
  }
  return paths.includes(moduleName);
}

// src/index.ts
var catchData = {};
function VuexPersistedstate({
  key = defaultOptions.key,
  paths = defaultOptions.paths,
  storage: storage2 = defaultOptions.storage,
  fetchBeforeUse = defaultOptions.fetchBeforeUse,
  fetchBeforeUseFn = defaultOptions.fetchBeforeUseFn
} = defaultOptions) {
  if (fetchBeforeUse) {
    catchData = fetchBeforeUseFn(key, storage2);
  }
  return (store) => {
    for (const key2 in catchData) {
      if (Object.prototype.hasOwnProperty.call(catchData, key2)) {
        const value = catchData[key2];
        store.commit(key2, value);
      }
    }
    store.subscribe((mutation, state) => {
      if (matchPaths(paths, mutation)) {
        catchData[mutation.type] = mutation.payload;
        storage2.setItem(key, catchData);
      }
    });
  };
}
export {
  VuexPersistedstate as default
};
